# 线程

## 线程模块threading

* 创建线程：
  * `线程=threading.Thread(target=任务函数名)`
* 启动线程（启动进程\(就绪状态\) -&gt; 等待cpu调度执行任务）：
  * `线程.start()`
* 查看任务是由哪个线程执行:
  * `print(threading.current_thread().pid)`
* 主线程守护\(待主线程的任务执行完 无论子线程任务是否完成 都退出\):
  * `子线程.setDaemon = True`
* 阻塞当前线程，直到调用join方法的那个线程执行完，再继续执行当前线程。
  * `线程.join()`

## 互斥锁

### 多线程共享全局变量出现资源竞争

* 方案一：线程同步（保证了数据安全，但牺牲了性能）
  * `线程1.join()`
  * `线程2.start()`
* 方案二：互斥锁
  * 创建锁：`锁=threading.Lock()` 
  * 在任务函数中：
    * 上锁: `lock.acquire()`
    * 数据处理，如`num+=1`
    * 解锁:`lock.release()`
  * 创建多个线程
  * 启动多个线程

### 死锁

`acquire() 和release() 是成双成对的` 多线程执行多任务 多任务方位全局变量 但是要遵循 互斥锁 好借好还再借不难。

